import Qutlin.*
import Mapper.Companion.Scales
import Plot.DataSet
import Plot.Symbols
import kotlinx.coroutines.*
import org.hipparchus.ode.nonstiff.GraggBulirschStoerIntegrator
import org.hipparchus.util.FastMath.*
import kotlin.math.pow

fun main() {
    completeSet()
}


fun completeSet(
    plotData: Boolean = true
) {
    runBlocking(Dispatchers.Default) {
        val samples = 10
        val tfSubdivision = 50
        val saveData = true
        val saveName = "2021 01 25"

        val gap = 10.0

        // * create Ornstein-Uhlenbeck noise
        val noise = OUNoise(initialSigma = 0.001, gamma = 10.0)


        val futures = listOf(
            async {
                tauSweeps(
                    0,
                    gap,
                    noise,
                    samples,
                    tfSubdivision,
                    saveData,
                    saveName,
                    plotData
                )
            },
            async {
                tauSweeps(
                    1,
                    gap,
                    noise,
                    samples,
                    tfSubdivision,
                    saveData,
                    saveName,
                    plotData
                )
            }
        )

        futures.awaitAll()
    }
}






// * pulse shape and coupling
// ? constant gap model with B = sqrt(eps^2 + Omega^2) = const IS ALREADY the optimal shaped pulse!
// ? Since B/dtheta = const :D
// ? so this is the shaped pulse:

class Eps(private val gap: Double) {
    operator fun invoke(t: Double, tf: Double) = gap * cos(PI * clamp(0.0, t, tf) / tf)
//    fun eps(t: Double, tau: Double) = gap * (1.0 - 2.0 * t/tau)
}

class Coupling(private val gap: Double) {
    operator fun invoke(ep: Double) = if (abs(ep) <= gap) sqrt(gap * gap - ep * ep) else 0.0
}

// * define Hamiltonian of the system
fun hamiltonian(ep: Double, Om: Double) = Operator(
    Pair(2, 2),
    complexArrayOf(
        ep, Om,
        Om, -ep
    ) * 0.5
)








fun integrate(
    initialState: Int,
    tf: Double,
    eps: (Double, Double) -> Double,
    hamiltonian: (Double) -> Operator,
    noiseType: NoiseType
): Pair<Double, Double> {
    val noise = Noise(tf, min(noiseType.initialSpacing, tf / 100.0), noiseType.wnDeltaRate)
    noise.generate(noiseType::envelope, rescaleWN = true)

    // * generate initial density matrix depending on the chosen initial eigenstate
//    val initSys = hamiltonian(eps(0.0,tf) + noise(0.0).real).eigenSystem()
    val initSys = hamiltonian(eps(0.0, tf)).eigenSystem() // * given as Pairs (eigenvalue, eigenvector)
    val rhoInitial = initSys[initialState].second.normalized().ketBra()

    // * generate the density matrices of the final eigenstates
//    val finalSys = hamiltonian(eps(tf,tf) + noise(tf).real).eigenSystem()
    val finalSys = hamiltonian(eps(tf, tf)).eigenSystem()
    val rho0 = finalSys[0].second.normalized().ketBra()
    val rho1 = finalSys[1].second.normalized().ketBra()

    // * define the ODE for the von Neumann equation
    fun ode(t: Double, rho: ComplexMatrix) =
//                        -I * commutator(rho, hamiltonian(eps(t,tf) ))
        -I * commutator(rho, hamiltonian(eps(t, tf) + noise(t).real))

    val (_, rRho) = solveEvolution(
        0.0, tf, rhoInitial, ::ode,
        integrator = GraggBulirschStoerIntegrator(
            Double.MIN_VALUE, noise.realSpacing,
            1e-8, 1e-8
        )
    )

    return Pair(
        (rho0 * rRho).trace().real,
        (rho1 * rRho).trace().real
    )
}









fun tauSweeps(
    initial: Int = 0,
    gap: Double = 1.0,
    noiseType: NoiseType,
    samples: Int = 20,
    tfSubdivisions: Int = 500,
    saveData: Boolean = true,
    saveName: String = "",
    plotData: Boolean = true
) {
    // * SETUP //////////////////////////////////////////
    val tfMin = -1.0
    val tfMax = 3.0
    val tf = linspace(tfMin, tfMax, tfSubdivisions).toList().map { 10.0.pow(it) }

    val filename = "results/$saveName $noiseType i${initial}_n$samples tf${tfMin}_${tfMax}_n${tfSubdivisions}.csv"


    val eps = Eps(gap)
    val coupling = Coupling(gap)


    // * prepare lists containing the results
    val p0 = List(samples) { MutableList(tf.size) { 0.0 } }
    val p1 = List(samples) { MutableList(tf.size) { 0.0 } }


    println("start solver...")
    runBlocking(Dispatchers.Default) {
//    runBlocking(Executors.newSingleThreadExecutor().asCoroutineDispatcher()) { // * single threaded calculation
        println("run blocking...")
        val futures = List(samples) { sample ->
            println("sample $sample")
            tf.mapIndexed { itf: Int, tf: Double ->
                async {
                    println("%3d / $samples : %3d / $tfSubdivisions : %4.2f".format(sample, itf, tf))

                    val res = integrate(
                        initial,
                        tf,
                        eps::invoke,
                        { ep -> hamiltonian(ep, coupling(ep)) },
                        noiseType
                    )
                    p0[sample][itf] = res.first
                    p1[sample][itf] = res.second
                }//.await()
            }
        }
        futures.forEach { it.awaitAll() }
    }
    println("solver finished.")


    val res = mutableListOf(tf)
    for (i in 0 until samples) {
        res.add(p0[i])
        res.add(p1[i])
    }

    if (saveData) {
        save(filename, res)
        println("saved as: $filename")
    }

    if (plotData) {
        val plot = Plot(
            DataSet(tf.zip(p0[0]) { x, y -> listOf(x, y) }, symbol = Symbols.None, color = Plot.colorPalette[0]),
            xScale = Scales.Log10, yScale = Scales.Log10, minY = 1e-6, maxY = 1.0
        )

        plot.addDataSet(
            DataSet(
                tf.zip(p1[0]) { x, y -> listOf(x, y) },
                symbol = Symbols.None,
                color = Plot.colorPalette[1]
            )
        )

        for (i in 1 until samples) {
            plot.addDataSet(
                DataSet(
                    tf.zip(p0[i]) { x, y -> listOf(x, y) },
                    symbol = Symbols.None,
                    color = Plot.colorPalette[0]
                )
            )
            plot.addDataSet(
                DataSet(
                    tf.zip(p1[i]) { x, y -> listOf(x, y) },
                    symbol = Symbols.None,
                    color = Plot.colorPalette[1]
                )
            )
        }
    }
}